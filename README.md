# 手写线程池

> 

## 并发和并行

> 并发：当`cpu`时间片足够小的时候，进程/线程的切换没有感知，在同一个时间段看起来是同时发生的
>
> 并行：多核环境中，进程/线程能够在同一时刻同时运行

##  CPU\IO密集

> `CPU`密集：进程指令多以计算为主
>
> `IO`密集：进程指令多以`IO`操作为主：设备，文件（磁盘）、网络操作（网卡也是`IO`，等待客户端连接），`IO`操作可以将当前进程阻塞

- 单核环境中，`cpu`密集不适合设计成多线程，线程切换上下文消耗性能，还需要将上个线程的信息保存到下一个线程

- 多核环境中，设计成多线程程序是必要的
- `IO`密集更适合设计成多线程

## 线程池

> 在业务到来的时候再创建线程，不仅导致系统资源占用突然上升，也导致业务的响应变慢。

### 线程

> `linux`下，`pthread`创建线程，从用户空间切换到内核空间，同时分配资源
>
> `32位linux`下，每个线程栈占用`8MB`，同时用户空间占`3G`，意味着`pthread`创建的线程数量只能在`380`左右（**3*1024/8 = 384**）

- 线程的创建、销毁是一个很”重“操作
- 线程栈占用大量内存
- 线程的上下文切换要大量时间
- 大量的线程同时被唤醒的时候，会导致负载上升，宕机（相当于打游戏的时候切换进程，再切回来会导致游戏卡死，可以看作大量线程被唤醒）
- 合适的线程数量：**当前`CPU`核心数**

###  fixed模式线程池

> 线程池的线程数量固定不变，`ThreadPool`创建时根据`CPU`核心数指定

### cached模式线程池

> 线程池的线程数量根据当前的`Task`数动态变化

## 线程互斥

> `lock`
>
> 临界区代码段
>
> `unlock`
>
> `c11`中使用`oop`去自动释放锁

- `mutex`，互斥锁
  - 资源计数`0-1`

- `atomic`，原子操作

## 线程同步/通信 

> 线程执行的先后关系

- `condition_variable（c11）`，用于拥有先后关系访问临界区代码段的多线程通信
  - `cv.wait(lock);`会将当前持有的`lock`释放掉，同时当前线程进入等待状态
  - `cv.notify_all(lock);`会通知所有持有这把`lock`的线程，将这些线程从等待状态切换成阻塞状态，这些线程还需要在抢到该`lock`后，才会进入就绪状态

- `semaphore(c20)`，用于简单的表示多线程之间的先后关系，不涉及临界区代码段的访问
  - 相当于没有资源计数限制的`mutex`锁`0-N` 
  - `sem.post()`，资源计数`+1`
  - `sem.wait()`，资源计数`-1`，没有则等待
  - `semaphore sem(1)`可以实现`mutex`，区别在于`mutex`的获取和释放是在同一线程中，`sem`可以在不同线程中调用

# 架构

> 以动态库形式提供，`linux:*.so`，`windows:*.dll`
>
> `Thread Pool`模型：`Thread list` 充当消费者、`Task list`充当生产者。`Task list`需要线程安全

- 不同的`Task`，伴随不同的类型，需要用**多态**实现，`virtual void run() = 0;`
- 线程和任务队列之间涉及线程通信，`mutex + condition_variable`
- `fixed`下线程队列不需要考虑线程安全；`cached`下由于线程池的动态变化，需要考虑线程安全
- `_taskList`不建议使用裸指针，当用户传入临时对象的时候，出了`submitTask()`语句会导致`Task`析构，使得`_taskList`中存的是已经析构了的对象。需要将`_taskList`中的对象生命周期拉长的同时，`run()`后自动释放资源，使用`shared_ptr`

## 基本使用

- `ThreadPool pool`
- `pool.setMode(fixed|cached)`
- `pool.start()`

## 执行结果的返回

> `c17`的`Any`类型

- `Result res = pool.submitTask()`
- `res.get().Cast<类型结果>()`

